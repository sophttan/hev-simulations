
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list = ls())
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 284765 15.3     664565 35.5   464468 24.9
Vcells 490458  3.8    8388608 64.0  1837328 14.1
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> library(foreach)
> library(doParallel)
Loading required package: iterators
Loading required package: parallel
> 
> # Set up the number of cores used for parallelization.
> message(detectCores())
32
> num_cores <- 32
> registerDoParallel(num_cores)
> 
> #########################
> #### SEIR Simulation ####
> #########################
> time <- 365 # Number of days.
> inf <- 7 # Average infectious period length.
> N <- 1000 # Population size.
> 
> create_hh <- function() {
+   # Randomly sample household sizes such that total population is 1000 
+   # individuals.
+   hh_size <- sample(x = c(3, 4, 5, 6), size = 340, replace = T)
+   
+   # Keep households such that total population is < 1000.
+   hh_size <- hh_size[which(cumsum(hh_size) < N)]
+   
+   leftover <- N - sum(hh_size)
+   if (leftover < 3) {
+     hh <- 1:length(hh_size)
+     sampled <- sample(hh[hh_size < 6], leftover)
+     hh_size[sampled] <- hh_size[sampled] + 1
+   } else {
+     hh_size <- c(hh_size, leftover)
+   }
+   return(hh_size)
+ }
> 
> SEIR_mix <- function(params, inf = 7, verbose = F) {
+   hh_size <- create_hh()
+   
+   # Create frame for running the simulation.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # S: susceptibility status.
+   # E: exposed status.
+   # E_count: number of days since exposed.
+   # I: infectious status.
+   # I_count: number of days since infectious.
+   # R: recovered status.
+   # INC: incubation period.
+   # INF: infectious period.
+   data <- data.frame(ID = 1:N,
+                      SIZE = rep(hh_size, times = hh_size),
+                      HH = rep(1:length(hh_size), times = hh_size), 
+                      S = c(0, rep(1, N - 1)), 
+                      E = c(1, rep(0, N - 1)),
+                      E_count = c(1, rep(0, N - 1)), 
+                      I = 0,
+                      I_count = 0, 
+                      R = 0, 
+                      INC = c(rlnorm(1, meanlog = log(29.8), sdlog = 0.45), rep(0, N - 1)),
+                      INF = 0)
+   
+   # Create frame for storing results.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # TYPE: the kind of infection: household (H), community (C), or both (B).
+   # TIME: when the individual became infectious.
+   # S_NUM: number of susceptible people in individual's household when their 
+   #        infectious period begins.
+   # I_NUM: number of people in household that this individual infected over 
+   #        their infectious period.
+   results <- data[, 1:3] %>% mutate(TYPE = NA, TIME = NA, S_NUM = NA, I_NUM = 0)
+   results$TYPE[1] <- '0'
+   
+   for(t in 1:time) {
+     if (verbose) {
+       if (t %% 10 == 0) {
+         cat(paste0(t, ' '))
+       }
+     }
+     
+     # Anyone who has been infectious for as many days as their infectious period
+     # is now recovered.
+     recovered <- (data$INF > 0) & (data$I_count == data$INF)
+     if(sum(recovered, na.rm = T) > 0) {
+       data$R[recovered] <- 1
+       data$I[recovered] <- 0
+       data$I_count[recovered] <- 0 
+     }
+     
+     new_inf <- (data$INC > 0) & (data$E_count == data$INC)
+     num_new_inf <- sum(new_inf, na.rm = T)
+     if(num_new_inf > 0) {
+       # Change status to newly infectious and add infectious period.
+       data$I[new_inf] <- 1
+       random_inf <- rnorm(num_new_inf, mean = inf, sd = 1) %>% round()
+       data$INF[new_inf] <- random_inf
+       
+       # Remove exposure status and exposure count.
+       data$E[new_inf] <- 0
+       data$E_count[new_inf] <- 0 
+       
+       # Record time at which infectious period starts.
+       results$TIME[new_inf] <- t
+       
+       # Save the number of susceptible people in each infectious individual's 
+       # household.
+       S_data <- data %>% group_by(HH) %>% 
+         mutate(S_TOT = sum(S)) %>% 
+         select(HH, S_TOT)
+       results$S_NUM[new_inf == 1] <- S_data$S_TOT[new_inf == 1]
+     }
+     
+     # I_H is the number of infections inside each household.
+     # I_C is the number of infections outside each household.
+     I_data <- data %>% group_by(HH) %>% 
+       mutate(I_H = sum(I)) %>% 
+       ungroup() %>% 
+       mutate(I_C = sum(I) - I_H)
+     
+     beta_H <- params[1]
+     beta_C <- params[2]
+     beta_E <- params[3]
+     risk_H <- pmin(beta_H * data$S * I_data$I_H / N, 1)
+     risk_C <- pmin(beta_C * data$S * I_data$I_C / N, 1)
+     risk_E <- pmin(beta_E * data$S, 1)
+ 
+     new_inf_H <- rbinom(N, 1, risk_H)
+     new_inf_C <- rbinom(N, 1, risk_C)
+     new_inf_E <- rbinom(N, 1, risk_E)
+     new_exposed <- (new_inf_H == 1) | (new_inf_C == 1) | (new_inf_E == 1)
+     num_new_exposed <- sum(new_exposed, na.rm = T)
+     if (num_new_exposed > 0) {
+       # Change status to newly exposed and add incubation period.
+       data$E[new_exposed] <- 1
+       random_inc <- rlnorm(num_new_exposed, meanlog = log(29.8), sdlog = 0.45) %>% round()
+       data$INC[new_exposed] <- random_inc
+       
+       # Remove susceptible status.
+       data$S[new_exposed] <- 0
+       
+       # Get number of new infections in each household.
+       I_data <- I_data %>%
+         select(ID, HH, I, I_H) %>%
+         mutate(new_I_H = new_inf_H) %>%
+         group_by(HH) %>%
+         # Find households with at least 1 currently infectious individual. If 
+         # exactly 1 infectious individual in household, assign all new H 
+         # exposures to that individual. If there are multiple infectious 
+         # individuals, assign all infections to the infectious individual with 
+         # the first ID.
+         mutate(new_I_H = ifelse(I == 1 & ID == first(ID[I == 1]), 
+                                 sum(new_I_H), 0))
+       
+       results$I_NUM <- results$I_NUM + I_data$new_I_H
+       
+       # Label infections types.
+       results$TYPE[new_inf_H == 1] <- 'H'
+       results$TYPE[new_inf_C == 1] <- 'C'
+       results$TYPE[new_inf_E == 1] <- 'E'
+       results$TYPE[(new_inf_H == 1) & (new_inf_C == 1)] <- 'HC'
+       results$TYPE[(new_inf_H == 1) & (new_inf_E == 1)] <- 'HE'
+       results$TYPE[(new_inf_C == 1) & (new_inf_E == 1)] <- 'CE'
+       results$TYPE[(new_inf_H == 1) & (new_inf_C == 1) & (new_inf_E == 1)] <- 'HCE'
+     }
+     
+     # Increment exposure and infectious counters.
+     data$E_count[data$E == 1] <- data$E_count[data$E == 1] + 1
+     data$I_count[data$I == 1] <- data$I_count[data$I == 1] + 1
+   }
+   return(results)
+ }
> 
> metrics <- function(results) {
+   # Incidence is the proportion of the population that became infected.
+   idc <- mean(!is.na(results$TIME))
+   
+   # The SAR is the average SAR for each individual that was infectious.
+   sar <- mean(results$I_NUM / results$S_NUM, na.rm = T)
+   
+   # The proportion of cases caused by household infections.
+   cases <- results[!is.na(results$TIME), ]
+   prp <- mean((cases$TYPE != 'E') & (cases$TYPE != '0'))
+ 
+   return(c(idc, sar, prp))
+ }
> 
> beta_Hs <- seq(26, 30, 1) # 5
> beta_Cs <- seq(0.000, 0.010, 0.001) # 11
> beta_Es <- seq(0.00001, 0.00015, 0.00001) # 15
> 
> d_H <- length(beta_Hs)
> d_C <- length(beta_Cs)
> d_E <- length(beta_Es)
> 
> reps <- 200
> idcs <- array(rep(NA, d_H * d_C * d_E * reps), dim = c(d_H, d_C, d_E, reps))
> sars <- array(rep(NA, d_H * d_C * d_E * reps), dim = c(d_H, d_C, d_E, reps))
> prps <- array(rep(NA, d_H * d_C * d_E * reps), dim = c(d_H, d_C, d_E, reps))
> t_tot <- 0
> for (i in 1:d_H) {
+   for (j in 1:d_C) {
+     for (k in 1:d_E) {
+       beta_H <- beta_Hs[i]
+       beta_C <- beta_Cs[j]
+       beta_E <- beta_Es[k]
+       
+       params <- c(beta_H, beta_C, beta_E)
+       
+       cat(paste0(format(beta_H, nsmall = 0), '/21\t', 
+                  format(beta_C, nsmall = 3), '/0.040\t',
+                  format(beta_E, nsmall = 5, scientific = F), '/0.00010\t'))
+         
+       t_0 <- Sys.time()
+       vals <- foreach (l = 1:reps, .combine = 'c') %dopar% {
+         results <- SEIR_mix(params) 
+         metrics(results)
+       }
+       t_1 <- Sys.time()
+       t_tot <- t_tot + (t_1 - t_0)
+         
+       cat(paste0(format(t_tot, nsmall = 2, digits = 4), '\t(', 
+                  format(t_1 - t_0, nsmall = 2, digits = 4), ')\t'))
+       
+       vals <- matrix(vals, reps, byrow = T)
+       idcs[i, j, k, ] <- vals[, 1]
+       sars[i, j, k, ] <- vals[, 2]
+       prps[i, j, k, ] <- vals[, 3]
+         
+       cat(paste0(format(round(mean(vals[, 1]), 3), nsmall = 3), '\t', 
+                  format(round(mean(vals[, 2]), 3), nsmall = 3), '\t', 
+                  format(round(mean(vals[, 3]), 3), nsmall = 3), '\n'))
+     }
+     cat('\n')
+     saveRDS(idcs, file = 'idcs.rds')
+     saveRDS(sars, file = 'sars.rds')
+     saveRDS(prps, file = 'prps.rds')
+     
+     write.table(idcs, file = 'idcs.txt', row.names = F, col.names = F)
+     write.table(sars, file = 'sars.txt', row.names = F, col.names = F)
+     write.table(prps, file = 'prps.txt', row.names = F, col.names = F)
+   }
+   message('\n')
+ }
26/21	0.000/0.040	0.00001/0.00010	51.73 secs	(51.73 secs)	0.006	NaN	NaN
26/21	0.000/0.040	0.00002/0.00010	106.43 secs	(54.70 secs)	0.012	NaN	NaN
26/21	0.000/0.040	0.00003/0.00010	164.96 secs	(58.53 secs)	0.017	0.155	0.413
26/21	0.000/0.040	0.00004/0.00010	228.20 secs	(1.054 mins)	0.024	0.168	0.439
26/21	0.000/0.040	0.00005/0.00010	292.72 secs	(1.075 mins)	0.029	0.164	0.444
26/21	0.000/0.040	0.00006/0.00010	361.18 secs	(1.141 mins)	0.037	0.159	0.439
26/21	0.000/0.040	0.00007/0.00010	431.24 secs	(1.168 mins)	0.042	0.168	0.446
26/21	0.000/0.040	0.00008/0.00010	503.80 secs	(1.209 mins)	0.047	0.161	0.436
26/21	0.000/0.040	0.00009/0.00010	581.10 secs	(1.288 mins)	0.054	0.166	0.441
26/21	0.000/0.040	0.00010/0.00010	661.08 secs	(1.333 mins)	0.059	0.164	0.441
26/21	0.000/0.040	0.00011/0.00010	741.79 secs	(1.345 mins)	0.064	0.160	0.435
26/21	0.000/0.040	0.00012/0.00010	826.23 secs	(1.407 mins)	0.069	0.162	0.434
26/21	0.000/0.040	0.00013/0.00010	912.56 secs	(1.439 mins)	0.076	0.167	0.442
26/21	0.000/0.040	0.00014/0.00010	1001.45 secs	(1.482 mins)	0.080	0.163	0.436
26/21	0.000/0.040	0.00015/0.00010	1090.48 secs	(1.484 mins)	0.085	0.167	0.439

26/21	0.001/0.040	0.00001/0.00010	1143.15 secs	(52.67 secs)	0.006	NaN	NaN
26/21	0.001/0.040	0.00002/0.00010	1201.01 secs	(57.86 secs)	0.012	0.148	0.400
26/21	0.001/0.040	0.00003/0.00010	1261.27 secs	(1.004 mins)	0.018	0.161	0.433
26/21	0.001/0.040	0.00004/0.00010	1323.95 secs	(1.045 mins)	0.024	0.159	0.430
26/21	0.001/0.040	0.00005/0.00010	1388.05 secs	(1.068 mins)	0.030	0.157	0.430
26/21	0.001/0.040	0.00006/0.00010	1455.91 secs	(1.131 mins)	0.036	0.164	0.439
26/21	0.001/0.040	0.00007/0.00010	1526.50 secs	(1.176 mins)	0.041	0.163	0.439
26/21	0.001/0.040	0.00008/0.00010	1599.77 secs	(1.221 mins)	0.048	0.161	0.444
26/21	0.001/0.040	0.00009/0.00010	1675.42 secs	(1.261 mins)	0.052	0.164	0.441
26/21	0.001/0.040	0.00010/0.00010	1753.62 secs	(1.303 mins)	0.058	0.163	0.445
26/21	0.001/0.040	0.00011/0.00010	1833.71 secs	(1.335 mins)	0.063	0.162	0.439
26/21	0.001/0.040	0.00012/0.00010	1918.66 secs	(1.416 mins)	0.069	0.163	0.438
26/21	0.001/0.040	0.00013/0.00010	2003.86 secs	(1.42 mins)	0.075	0.165	0.442
26/21	0.001/0.040	0.00014/0.00010	2091.96 secs	(1.468 mins)	0.080	0.165	0.442
26/21	0.001/0.040	0.00015/0.00010	2184.55 secs	(1.543 mins)	0.086	0.162	0.439

26/21	0.002/0.040	0.00001/0.00010	2237.80 secs	(53.25 secs)	0.006	NaN	NaN
26/21	0.002/0.040	0.00002/0.00010	2294.38 secs	(56.58 secs)	0.012	0.154	0.416
26/21	0.002/0.040	0.00003/0.00010	2353.48 secs	(59.10 secs)	0.019	0.162	0.440
26/21	0.002/0.040	0.00004/0.00010	2417.21 secs	(1.062 mins)	0.025	0.163	0.440
26/21	0.002/0.040	0.00005/0.00010	2482.15 secs	(1.082 mins)	0.029	0.157	0.434
26/21	0.002/0.040	0.00006/0.00010	2550.91 secs	(1.146 mins)	0.037	0.169	0.451
26/21	0.002/0.040	0.00007/0.00010	2623.50 secs	(1.21 mins)	0.043	0.164	0.451
26/21	0.002/0.040	0.00008/0.00010	2699.03 secs	(1.259 mins)	0.047	0.161	0.443
26/21	0.002/0.040	0.00009/0.00010	2775.65 secs	(1.277 mins)	0.053	0.159	0.441
26/21	0.002/0.040	0.00010/0.00010	2854.47 secs	(1.314 mins)	0.060	0.163	0.454
26/21	0.002/0.040	0.00011/0.00010	2936.06 secs	(1.36 mins)	0.066	0.167	0.453
26/21	0.002/0.040	0.00012/0.00010	3021.75 secs	(1.428 mins)	0.071	0.166	0.451
26/21	0.002/0.040	0.00013/0.00010	3108.01 secs	(1.438 mins)	0.077	0.167	0.453
26/21	0.002/0.040	0.00014/0.00010	3197.87 secs	(1.498 mins)	0.081	0.162	0.444
26/21	0.002/0.040	0.00015/0.00010	3290.07 secs	(1.537 mins)	0.089	0.166	0.453

26/21	0.003/0.040	0.00001/0.00010	3343.79 secs	(53.72 secs)	0.006	NaN	NaN
26/21	0.003/0.040	0.00002/0.00010	3400.12 secs	(56.33 secs)	0.012	0.155	0.420
26/21	0.003/0.040	0.00003/0.00010	3459.43 secs	(59.31 secs)	0.018	0.157	0.435
26/21	0.003/0.040	0.00004/0.00010	3522.07 secs	(1.044 mins)	0.024	0.158	0.450
26/21	0.003/0.040	0.00005/0.00010	3587.59 secs	(1.092 mins)	0.030	0.162	0.448
26/21	0.003/0.040	0.00006/0.00010	3656.29 secs	(1.145 mins)	0.037	0.165	0.455
26/21	0.003/0.040	0.00007/0.00010	3728.14 secs	(1.198 mins)	0.042	0.162	0.450
26/21	0.003/0.040	0.00008/0.00010	3803.06 secs	(1.249 mins)	0.049	0.167	0.458
26/21	0.003/0.040	0.00009/0.00010	3880.65 secs	(1.293 mins)	0.055	0.163	0.455
26/21	0.003/0.040	0.00010/0.00010	3960.18 secs	(1.326 mins)	0.059	0.163	0.448
26/21	0.003/0.040	0.00011/0.00010	