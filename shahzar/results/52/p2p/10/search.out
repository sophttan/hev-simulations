
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list = ls())
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 284765 15.3     664565 35.5   464468 24.9
Vcells 490458  3.8    8388608 64.0  1837328 14.1
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> library(foreach)
> library(doParallel)
Loading required package: iterators
Loading required package: parallel
> 
> # Set up the number of cores used for parallelization.
> message(detectCores())
24
> num_cores <- 24
> registerDoParallel(num_cores)
> 
> #########################
> #### SEIR Simulation ####
> #########################
> time <- 365 # Number of days.
> inf <- 7 # Average infectious period length.
> N <- 1000 # Population size.
> 
> create_hh <- function() {
+   # Randomly sample household sizes such that total population is 1000 
+   # individuals.
+   hh_size <- sample(x = c(3, 4, 5, 6), size = 340, replace = T)
+   
+   # Keep households such that total population is < 1000.
+   hh_size <- hh_size[which(cumsum(hh_size) < N)]
+   
+   leftover <- N - sum(hh_size)
+   if (leftover < 3) {
+     hh <- 1:length(hh_size)
+     sampled <- sample(hh[hh_size < 6], leftover)
+     hh_size[sampled] <- hh_size[sampled] + 1
+   } else {
+     hh_size <- c(hh_size, leftover)
+   }
+   return(hh_size)
+ }
> 
> SEIR_p2p <- function(params, inf = 7, verbose = F) {
+   hh_size <- create_hh()
+   
+   # Create frame for running the simulation.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # S: susceptibility status.
+   # E: exposed status.
+   # E_count: number of days since exposed.
+   # I: infectious status.
+   # I_count: number of days since infectious.
+   # R: recovered status.
+   # INC: incubation period.
+   # INF: infectious period.
+   data <- data.frame(ID = 1:N,
+                      SIZE = rep(hh_size, times = hh_size),
+                      HH = rep(1:length(hh_size), times = hh_size), 
+                      S = c(0, rep(1, N - 1)), 
+                      E = c(1, rep(0, N - 1)),
+                      E_count = c(1, rep(0, N - 1)), 
+                      I = 0,
+                      I_count = 0, 
+                      R = 0, 
+                      INC = c(round(rlnorm(1, meanlog = log(29.8), sdlog = 0.45)), rep(0, N - 1)),
+                      INF = 0)
+   
+   # Create frame for storing results.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # TYPE: the kind of infection: household (H), community (C), or both (B).
+   # TIME: when the individual became infectious.
+   # S_NUM: number of susceptible people in individual's household when their 
+   #        infectious period begins.
+   # I_NUM: number of people in household that this individual infected over 
+   #        their infectious period.
+   results <- data[, 1:3] %>% mutate(TYPE = NA, TIME = NA, S_NUM = NA, I_NUM = 0)
+   results$TYPE[1] <- '0'
+   
+   for(t in 1:time) {
+     if (verbose) {
+       if (t %% 10 == 0) {
+         cat(paste0(t, ' '))
+       }
+     }
+     
+     # Anyone who has been infectious for as many days as their infectious period
+     # is now recovered.
+     recovered <- (data$INF > 0) & (data$I_count == data$INF)
+     if(sum(recovered, na.rm = T) > 0) {
+       data$R[recovered] <- 1
+       data$I[recovered] <- 0
+       data$I_count[recovered] <- 0 
+     }
+     
+     # Anyone who has been incubating for as many days as their incubation period
+     # is now infectious.
+     new_inf <- (data$INC > 0) & (data$E_count == data$INC)
+     num_new_inf <- sum(new_inf, na.rm = T)
+     if(num_new_inf > 0) {
+       # Change status to newly infectious and add infectious period.
+       data$I[new_inf] <- 1
+       random_inf <- rnorm(num_new_inf, mean = inf, sd = 1) %>% round()
+       data$INF[new_inf] <- random_inf
+       
+       # Remove exposure status and exposure count.
+       data$E[new_inf] <- 0
+       data$E_count[new_inf] <- 0 
+       
+       # Record time at which infectious period starts.
+       results$TIME[new_inf] <- t
+       
+       # Save the number of susceptible people in each infectious individual's 
+       # household.
+       S_data <- data %>% group_by(HH) %>% 
+         mutate(S_tot = sum(S)) %>% 
+         select(HH, S_tot)
+       results$S_NUM[new_inf == 1] <- S_data$S_tot[new_inf == 1]
+     }
+     
+     # I_H is the number of infections inside each household.
+     # I_C is the number of infections outside each household.
+     I_data <- data %>% group_by(HH) %>% 
+       mutate(I_H = sum(I)) %>% 
+       ungroup() %>% 
+       mutate(I_C = sum(I) - I_H)
+     
+     # Calculate household risk and community risk.
+     beta_H <- params[1]
+     beta_C <- params[2]
+     risk_H <- pmin(beta_H * data$S * I_data$I_H / N, 1)
+     risk_C <- pmin(beta_C * data$S * I_data$I_C / N, 1)
+     
+     # Each individual is infected from their household or community 
+     # independently with probabilities risk_H and risk_C.
+     new_inf_H <- rbinom(N, 1, risk_H)
+     new_inf_C <- rbinom(N, 1, risk_C)
+     
+     new_exposed <- (new_inf_H == 1) | (new_inf_C == 1)
+     num_new_exposed <- sum(new_exposed, na.rm = T)
+     if (num_new_exposed > 0) {
+       # Change status to newly exposed and add incubation period.
+       data$E[new_exposed] <- 1
+       random_inc <- rlnorm(num_new_exposed, meanlog = log(29.8), sdlog = 0.45) %>% round()
+       data$INC[new_exposed] <- random_inc
+       
+       # Remove susceptible status.
+       data$S[new_exposed] <- 0
+       
+       # Get number of new infections in each household.
+       I_data <- I_data %>%
+         select(ID, HH, I, I_H) %>%
+         mutate(new_I_H = new_inf_H) %>%
+         group_by(HH) %>%
+         # Find households with at least 1 currently infectious individual. If 
+         # exactly 1 infectious individual in household, assign all new H 
+         # exposures to that individual. If there are multiple infectious 
+         # individuals, assign all infections to the infectious individual with 
+         # the first ID.
+         mutate(new_I_H = ifelse(I == 1 & ID == first(ID[I == 1]), 
+                                 sum(new_I_H), 0))
+       
+       results$I_NUM <- results$I_NUM + I_data$new_I_H
+       
+       # Label infection types.
+       results$TYPE[new_inf_C == 1] <- 'C'
+       results$TYPE[new_inf_H == 1] <- 'H'
+       results$TYPE[(new_inf_H == 1) & (new_inf_C == 1)] <- 'HC'
+     }
+     
+     # Increment exposure and infectious counters.
+     data$E_count[data$E == 1] <- data$E_count[data$E == 1] + 1
+     data$I_count[data$I == 1] <- data$I_count[data$I == 1] + 1
+   }
+   return(results)
+ }
> 
> metrics <- function(results) {
+   # Incidence is the proportion of the population that became infected.
+   idc <- mean(!is.na(results$TIME))
+   
+   # The SAR is the average SAR for each individual that was infectious.
+   sar <- mean(results$I_NUM / results$S_NUM, na.rm = T)
+ 
+   return(c(idc, sar))
+ }
> 
> beta_Hs <- seq(49, 53, 0.1) # 41
> beta_Cs <- seq(0.091, 0.11, 0.001) #20
> 
> d_H <- length(beta_Hs)
> d_C <- length(beta_Cs)
> 
> reps <- 200
> idcs <- array(rep(NA, d_H * d_C * reps), dim = c(d_H, d_C, reps))
> sars <- array(rep(NA, d_H * d_C * reps), dim = c(d_H, d_C, reps))
> t_tot <- 0
> for (i in 1:d_H) {
+     for (j in 1:d_C) {
+       beta_H <- beta_Hs[i]
+       beta_C <- beta_Cs[j]
+       params <- c(beta_H, beta_C)
+       
+       cat(paste0(format(beta_H, nsmall = 1, digits = 3), '/70.0\t', 
+                  format(beta_C, nsmall = 3, digits = 3), '/0.500\t'))
+ 
+       t_0 <- Sys.time()
+       vals <- foreach (l = 1:reps, .combine = 'c') %dopar% {
+         results <- SEIR_p2p(params) 
+         metrics(results)
+       }
+       t_1 <- Sys.time()
+       t_tot <- t_tot + (t_1 - t_0)
+ 
+       cat(paste0(format(t_tot, nsmall = 2, digits = 4), '\t(', 
+                  format(t_1 - t_0, nsmall = 2, digits = 4), ')\t'))
+ 
+       vals <- matrix(vals, reps, byrow = T)
+       idcs[i, j, ] <- vals[, 1]
+       sars[i, j, ] <- vals[, 2]
+ 
+       cat(paste0(format(round(mean(vals[, 1]), 3), nsmall = 3), '\t',
+                  format(round(mean(vals[, 2]), 3), nsmall = 3), '\n'))
+       
+       saveRDS(idcs, file = 'idcs.rds')
+       saveRDS(sars, file = 'sars.rds')
+       write.table(idcs, file = 'idcs.txt', row.names = F, col.names = F)
+       write.table(sars, file = 'sars.txt', row.names = F, col.names = F)
+     }
+   message('\n')
+ }
49.0/70.0	0.091/0.500	1.181 mins	(1.181 mins)	0.076	0.221
49.0/70.0	0.092/0.500	2.328 mins	(1.147 mins)	0.082	0.224
49.0/70.0	0.093/0.500	3.61 mins	(1.282 mins)	0.077	0.236
49.0/70.0	0.094/0.500	4.86 mins	(1.25 mins)	0.080	0.236
49.0/70.0	0.095/0.500	6.007 mins	(1.148 mins)	0.070	0.220
49.0/70.0	0.096/0.500	7.229 mins	(1.222 mins)	0.089	0.229
49.0/70.0	0.097/0.500	8.431 mins	(1.202 mins)	0.082	0.230
49.0/70.0	0.098/0.500	9.713 mins	(1.282 mins)	0.096	0.223
49.0/70.0	0.099/0.500	10.88 mins	(1.168 mins)	0.087	0.227
49.0/70.0	0.100/0.500	12.11 mins	(1.225 mins)	0.091	0.208
49.0/70.0	0.101/0.500	13.31 mins	(1.204 mins)	0.099	0.218
49.0/70.0	0.102/0.500	14.61 mins	(1.305 mins)	0.107	0.229
49.0/70.0	0.103/0.500	15.86 mins	(1.243 mins)	0.105	0.222
49.0/70.0	0.104/0.500	17.15 mins	(1.289 mins)	0.108	0.227
49.0/70.0	0.105/0.500	18.53 mins	(1.385 mins)	0.112	0.233
49.0/70.0	0.106/0.500	19.80 mins	(1.273 mins)	0.122	0.226
49.0/70.0	0.107/0.500	21.18 mins	(1.378 mins)	0.129	0.222
49.0/70.0	0.108/0.500	22.61 mins	(1.431 mins)	0.141	0.234
49.0/70.0	0.109/0.500	23.92 mins	(1.306 mins)	0.118	0.211
49.0/70.0	0.110/0.500	25.25 mins	(1.326 mins)	0.128	0.227


49.1/70.0	0.091/0.500	26.39 mins	(1.142 mins)	0.067	0.237
49.1/70.0	0.092/0.500	27.44 mins	(1.05 mins)	0.061	0.226
49.1/70.0	0.093/0.500	28.62 mins	(1.18 mins)	0.078	0.219
49.1/70.0	0.094/0.500	29.87 mins	(1.258 mins)	0.076	0.217
49.1/70.0	0.095/0.500	31.07 mins	(1.197 mins)	0.089	0.246
49.1/70.0	0.096/0.500	32.32 mins	(1.252 mins)	0.084	0.205
49.1/70.0	0.097/0.500	33.58 mins	(1.257 mins)	0.089	0.231
49.1/70.0	0.098/0.500	34.82 mins	(1.242 mins)	0.086	0.234
49.1/70.0	0.099/0.500	36.15 mins	(1.328 mins)	0.094	0.221
49.1/70.0	0.100/0.500	37.53 mins	(1.377 mins)	0.102	0.227
49.1/70.0	0.101/0.500	38.89 mins	(1.362 mins)	0.110	0.241
49.1/70.0	0.102/0.500	40.29 mins	(1.397 mins)	0.116	0.230
49.1/70.0	0.103/0.500	41.67 mins	(1.382 mins)	0.092	0.208
49.1/70.0	0.104/0.500	43.04 mins	(1.368 mins)	0.114	0.234
49.1/70.0	0.105/0.500	44.41 mins	(1.373 mins)	0.098	0.224
49.1/70.0	0.106/0.500	45.80 mins	(1.392 mins)	0.116	0.229
49.1/70.0	0.107/0.500	47.32 mins	(1.519 mins)	0.132	0.232
49.1/70.0	0.108/0.500	48.85 mins	(1.527 mins)	0.125	0.210
49.1/70.0	0.109/0.500	50.36 mins	(1.515 mins)	0.127	0.242
49.1/70.0	0.110/0.500	51.84 mins	(1.482 mins)	0.131	0.213


49.2/70.0	0.091/0.500	53.14 mins	(1.294 mins)	0.072	0.235
49.2/70.0	0.092/0.500	54.34 mins	(1.20 mins)	0.064	0.223
49.2/70.0	0.093/0.500	55.71 mins	(1.369 mins)	0.087	0.241
49.2/70.0	0.094/0.500	57.00 mins	(1.297 mins)	0.074	0.230
49.2/70.0	0.095/0.500	58.43 mins	(1.425 mins)	0.078	0.223
49.2/70.0	0.096/0.500	59.78 mins	(1.347 mins)	0.082	0.210
49.2/70.0	0.097/0.500	61.09 mins	(1.314 mins)	0.081	0.214
49.2/70.0	0.098/0.500	62.43 mins	(1.345 mins)	0.094	0.228
49.2/70.0	0.099/0.500	63.78 mins	(1.35 mins)	0.086	0.223
49.2/70.0	0.100/0.500	65.10 mins	(1.31 mins)	0.090	0.206
49.2/70.0	0.101/0.500	66.32 mins	(1.222 mins)	0.098	0.236
49.2/70.0	0.102/0.500	67.62 mins	(1.299 mins)	0.105	0.228
49.2/70.0	0.103/0.500	68.86 mins	(1.245 mins)	0.100	0.231
49.2/70.0	0.104/0.500	70.09 mins	(1.228 mins)	0.105	0.213
49.2/70.0	0.105/0.500	