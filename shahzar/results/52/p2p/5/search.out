
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list = ls())
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 284765 15.3     664565 35.5   464468 24.9
Vcells 490458  3.8    8388608 64.0  1837328 14.1
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> library(foreach)
> library(doParallel)
Loading required package: iterators
Loading required package: parallel
> 
> # Set up the number of cores used for parallelization.
> message(detectCores())
24
> num_cores <- 24
> registerDoParallel(num_cores)
> 
> #########################
> #### SEIR Simulation ####
> #########################
> time <- 365 # Number of days.
> inf <- 7 # Average infectious period length.
> N <- 1000 # Population size.
> 
> create_hh <- function() {
+   # Randomly sample household sizes such that total population is 1000 
+   # individuals.
+   hh_size <- sample(x = c(3, 4, 5, 6), size = 340, replace = T)
+   
+   # Keep households such that total population is < 1000.
+   hh_size <- hh_size[which(cumsum(hh_size) < N)]
+   
+   leftover <- N - sum(hh_size)
+   if (leftover < 3) {
+     hh <- 1:length(hh_size)
+     sampled <- sample(hh[hh_size < 6], leftover)
+     hh_size[sampled] <- hh_size[sampled] + 1
+   } else {
+     hh_size <- c(hh_size, leftover)
+   }
+   return(hh_size)
+ }
> 
> SEIR_p2p <- function(params, inf = 7, verbose = F) {
+   hh_size <- create_hh()
+   
+   # Create frame for running the simulation.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # S: susceptibility status.
+   # E: exposed status.
+   # E_count: number of days since exposed.
+   # I: infectious status.
+   # I_count: number of days since infectious.
+   # R: recovered status.
+   # INC: incubation period.
+   # INF: infectious period.
+   data <- data.frame(ID = 1:N,
+                      SIZE = rep(hh_size, times = hh_size),
+                      HH = rep(1:length(hh_size), times = hh_size), 
+                      S = c(0, rep(1, N - 1)), 
+                      E = c(1, rep(0, N - 1)),
+                      E_count = c(1, rep(0, N - 1)), 
+                      I = 0,
+                      I_count = 0, 
+                      R = 0, 
+                      INC = c(round(rlnorm(1, meanlog = log(29.8), sdlog = 0.45)), rep(0, N - 1)),
+                      INF = 0)
+   
+   # Create frame for storing results.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # TYPE: the kind of infection: household (H), community (C), or both (B).
+   # TIME: when the individual became infectious.
+   # S_NUM: number of susceptible people in individual's household when their 
+   #        infectious period begins.
+   # I_NUM: number of people in household that this individual infected over 
+   #        their infectious period.
+   results <- data[, 1:3] %>% mutate(TYPE = NA, TIME = NA, S_NUM = NA, I_NUM = 0)
+   results$TYPE[1] <- '0'
+   
+   for(t in 1:time) {
+     if (verbose) {
+       if (t %% 10 == 0) {
+         cat(paste0(t, ' '))
+       }
+     }
+     
+     # Anyone who has been infectious for as many days as their infectious period
+     # is now recovered.
+     recovered <- (data$INF > 0) & (data$I_count == data$INF)
+     if(sum(recovered, na.rm = T) > 0) {
+       data$R[recovered] <- 1
+       data$I[recovered] <- 0
+       data$I_count[recovered] <- 0 
+     }
+     
+     # Anyone who has been incubating for as many days as their incubation period
+     # is now infectious.
+     new_inf <- (data$INC > 0) & (data$E_count == data$INC)
+     num_new_inf <- sum(new_inf, na.rm = T)
+     if(num_new_inf > 0) {
+       # Change status to newly infectious and add infectious period.
+       data$I[new_inf] <- 1
+       random_inf <- rnorm(num_new_inf, mean = inf, sd = 1) %>% round()
+       data$INF[new_inf] <- random_inf
+       
+       # Remove exposure status and exposure count.
+       data$E[new_inf] <- 0
+       data$E_count[new_inf] <- 0 
+       
+       # Record time at which infectious period starts.
+       results$TIME[new_inf] <- t
+       
+       # Save the number of susceptible people in each infectious individual's 
+       # household.
+       S_data <- data %>% group_by(HH) %>% 
+         mutate(S_tot = sum(S)) %>% 
+         select(HH, S_tot)
+       results$S_NUM[new_inf == 1] <- S_data$S_tot[new_inf == 1]
+     }
+     
+     # I_H is the number of infections inside each household.
+     # I_C is the number of infections outside each household.
+     I_data <- data %>% group_by(HH) %>% 
+       mutate(I_H = sum(I)) %>% 
+       ungroup() %>% 
+       mutate(I_C = sum(I) - I_H)
+     
+     # Calculate household risk and community risk.
+     beta_H <- params[1]
+     beta_C <- params[2]
+     risk_H <- pmin(beta_H * data$S * I_data$I_H / N, 1)
+     risk_C <- pmin(beta_C * data$S * I_data$I_C / N, 1)
+     
+     # Each individual is infected from their household or community 
+     # independently with probabilities risk_H and risk_C.
+     new_inf_H <- rbinom(N, 1, risk_H)
+     new_inf_C <- rbinom(N, 1, risk_C)
+     
+     new_exposed <- (new_inf_H == 1) | (new_inf_C == 1)
+     num_new_exposed <- sum(new_exposed, na.rm = T)
+     if (num_new_exposed > 0) {
+       # Change status to newly exposed and add incubation period.
+       data$E[new_exposed] <- 1
+       random_inc <- rlnorm(num_new_exposed, meanlog = log(29.8), sdlog = 0.45) %>% round()
+       data$INC[new_exposed] <- random_inc
+       
+       # Remove susceptible status.
+       data$S[new_exposed] <- 0
+       
+       # Get number of new infections in each household.
+       I_data <- I_data %>%
+         select(ID, HH, I, I_H) %>%
+         mutate(new_I_H = new_inf_H) %>%
+         group_by(HH) %>%
+         # Find households with at least 1 currently infectious individual. If 
+         # exactly 1 infectious individual in household, assign all new H 
+         # exposures to that individual. If there are multiple infectious 
+         # individuals, assign all infections to the infectious individual with 
+         # the first ID.
+         mutate(new_I_H = ifelse(I == 1 & ID == first(ID[I == 1]), 
+                                 sum(new_I_H), 0))
+       
+       results$I_NUM <- results$I_NUM + I_data$new_I_H
+       
+       # Label infection types.
+       results$TYPE[new_inf_C == 1] <- 'C'
+       results$TYPE[new_inf_H == 1] <- 'H'
+       results$TYPE[(new_inf_H == 1) & (new_inf_C == 1)] <- 'HC'
+     }
+     
+     # Increment exposure and infectious counters.
+     data$E_count[data$E == 1] <- data$E_count[data$E == 1] + 1
+     data$I_count[data$I == 1] <- data$I_count[data$I == 1] + 1
+   }
+   return(results)
+ }
> 
> metrics <- function(results) {
+   # Incidence is the proportion of the population that became infected.
+   idc <- mean(!is.na(results$TIME))
+   
+   # The SAR is the average SAR for each individual that was infectious.
+   sar <- mean(results$I_NUM / results$S_NUM, na.rm = T)
+ 
+   return(c(idc, sar))
+ }
> 
> beta_Hs <- seq(49, 53, 0.1) # 41
> beta_Cs <- seq(0.07, 0.09, 0.001) #21
> 
> d_H <- length(beta_Hs)
> d_C <- length(beta_Cs)
> 
> reps <- 200
> idcs <- array(rep(NA, d_H * d_C * reps), dim = c(d_H, d_C, reps))
> sars <- array(rep(NA, d_H * d_C * reps), dim = c(d_H, d_C, reps))
> t_tot <- 0
> for (i in 1:d_H) {
+     for (j in 1:d_C) {
+       beta_H <- beta_Hs[i]
+       beta_C <- beta_Cs[j]
+       params <- c(beta_H, beta_C)
+       
+       cat(paste0(format(beta_H, nsmall = 1, digits = 3), '/70.0\t', 
+                  format(beta_C, nsmall = 3, digits = 3), '/0.500\t'))
+ 
+       t_0 <- Sys.time()
+       vals <- foreach (l = 1:reps, .combine = 'c') %dopar% {
+         results <- SEIR_p2p(params) 
+         metrics(results)
+       }
+       t_1 <- Sys.time()
+       t_tot <- t_tot + (t_1 - t_0)
+ 
+       cat(paste0(format(t_tot, nsmall = 2, digits = 4), '\t(', 
+                  format(t_1 - t_0, nsmall = 2, digits = 4), ')\t'))
+ 
+       vals <- matrix(vals, reps, byrow = T)
+       idcs[i, j, ] <- vals[, 1]
+       sars[i, j, ] <- vals[, 2]
+ 
+       cat(paste0(format(round(mean(vals[, 1]), 3), nsmall = 3), '\t',
+                  format(round(mean(vals[, 2]), 3), nsmall = 3), '\n'))
+       
+       saveRDS(idcs, file = 'idcs.rds')
+       saveRDS(sars, file = 'sars.rds')
+       write.table(idcs, file = 'idcs.txt', row.names = F, col.names = F)
+       write.table(sars, file = 'sars.txt', row.names = F, col.names = F)
+     }
+   message('\n')
+ }
49.0/70.0	0.070/0.500	59.42 secs	(59.42 secs)	0.030	0.209
49.0/70.0	0.071/0.500	115.73 secs	(56.32 secs)	0.036	0.213
49.0/70.0	0.072/0.500	171.41 secs	(55.67 secs)	0.031	0.217
49.0/70.0	0.073/0.500	226.22 secs	(54.81 secs)	0.031	0.228
49.0/70.0	0.074/0.500	287.24 secs	(1.017 mins)	0.043	0.240
49.0/70.0	0.075/0.500	345.42 secs	(58.18 secs)	0.035	0.241
49.0/70.0	0.076/0.500	405.76 secs	(1.006 mins)	0.037	0.203
49.0/70.0	0.077/0.500	468.23 secs	(1.041 mins)	0.041	0.252
49.0/70.0	0.078/0.500	534.15 secs	(1.099 mins)	0.048	0.230
49.0/70.0	0.079/0.500	593.32 secs	(59.18 secs)	0.043	0.202
49.0/70.0	0.080/0.500	653.12 secs	(59.79 secs)	0.041	0.236
49.0/70.0	0.081/0.500	714.14 secs	(1.017 mins)	0.047	0.211
49.0/70.0	0.082/0.500	775.40 secs	(1.021 mins)	0.052	0.224
49.0/70.0	0.083/0.500	844.75 secs	(1.156 mins)	0.045	0.207
49.0/70.0	0.084/0.500	908.52 secs	(1.063 mins)	0.046	0.213
49.0/70.0	0.085/0.500	973.53 secs	(1.084 mins)	0.059	0.233
49.0/70.0	0.086/0.500	1039.22 secs	(1.095 mins)	0.062	0.232
49.0/70.0	0.087/0.500	1106.82 secs	(1.127 mins)	0.061	0.236
49.0/70.0	0.088/0.500	1174.33 secs	(1.125 mins)	0.057	0.227
49.0/70.0	0.089/0.500	1246.67 secs	(1.206 mins)	0.063	0.232
49.0/70.0	0.090/0.500	1314.30 secs	(1.127 mins)	0.065	0.219


49.1/70.0	0.070/0.500	1367.35 secs	(53.05 secs)	0.029	0.209
49.1/70.0	0.071/0.500	1425.54 secs	(58.19 secs)	0.032	0.233
49.1/70.0	0.072/0.500	1480.41 secs	(54.87 secs)	0.029	0.236
49.1/70.0	0.073/0.500	1535.28 secs	(54.87 secs)	0.034	0.229
49.1/70.0	0.074/0.500	1597.70 secs	(1.04 mins)	0.040	0.223
49.1/70.0	0.075/0.500	1653.92 secs	(56.23 secs)	0.034	0.222
49.1/70.0	0.076/0.500	1715.09 secs	(1.019 mins)	0.040	0.214
49.1/70.0	0.077/0.500	1776.48 secs	(1.023 mins)	0.045	0.219
49.1/70.0	0.078/0.500	1838.47 secs	(1.033 mins)	0.045	0.218
49.1/70.0	0.079/0.500	1900.00 secs	(1.025 mins)	0.046	0.224
49.1/70.0	0.080/0.500	1961.74 secs	(1.029 mins)	0.044	0.223
49.1/70.0	0.081/0.500	2025.06 secs	(1.055 mins)	0.045	0.217
49.1/70.0	0.082/0.500	2088.89 secs	(1.064 mins)	0.052	0.229
49.1/70.0	0.083/0.500	2150.37 secs	(1.025 mins)	0.050	0.213
49.1/70.0	0.084/0.500	2218.04 secs	(1.128 mins)	0.051	0.215
49.1/70.0	0.085/0.500	2284.46 secs	(1.107 mins)	0.060	0.219
49.1/70.0	0.086/0.500	2347.80 secs	(1.056 mins)	0.053	0.214
49.1/70.0	0.087/0.500	2416.46 secs	(1.144 mins)	0.065	0.231
49.1/70.0	0.088/0.500	2484.48 secs	(1.134 mins)	0.059	0.223
49.1/70.0	0.089/0.500	2551.78 secs	(1.122 mins)	0.065	0.232
49.1/70.0	0.090/0.500	2621.52 secs	(1.162 mins)	0.069	0.219


49.2/70.0	0.070/0.500	2687.07 secs	(1.092 mins)	0.030	0.229
49.2/70.0	0.071/0.500	2744.27 secs	(57.20 secs)	0.034	0.211
49.2/70.0	0.072/0.500	2800.76 secs	(56.49 secs)	0.029	0.220
49.2/70.0	0.073/0.500	2857.67 secs	(56.91 secs)	0.034	0.224
49.2/70.0	0.074/0.500	2917.91 secs	(1.004 mins)	0.033	0.225
49.2/70.0	0.075/0.500	2978.36 secs	(1.008 mins)	0.037	0.231
49.2/70.0	0.076/0.500	3041.72 secs	(1.056 mins)	0.039	0.211
49.2/70.0	0.077/0.500	3104.18 secs	(1.041 mins)	0.040	0.214
49.2/70.0	0.078/0.500	3164.37 secs	(1.003 mins)	0.039	0.213
49.2/70.0	0.079/0.500	3228.78 secs	(1.074 mins)	0.043	0.227
49.2/70.0	0.080/0.500	3294.36 secs	(1.093 mins)	0.042	0.220
49.2/70.0	0.081/0.500	3360.10 secs	(1.096 mins)	0.050	0.224
49.2/70.0	0.082/0.500	3423.85 secs	(1.062 mins)	0.047	0.218
49.2/70.0	0.083/0.500	3489.03 secs	(1.086 mins)	0.050	0.223
49.2/70.0	0.084/0.500	3565.28 secs	(1.271 mins)	0.057	0.205
49.2/70.0	0.085/0.500	3639.40 secs	(1.235 mins)	0.060	0.227
49.2/70.0	0.086/0.500	3705.92 secs	(1.109 mins)	0.053	0.230
49.2/70.0	0.087/0.500	3772.32 secs	(1.107 mins)	0.052	0.201
49.2/70.0	0.088/0.500	3843.29 secs	(1.183 mins)	0.065	0.221
49.2/70.0	0.089/0.500	3919.44 secs	(1.269 mins)	0.067	0.227
49.2/70.0	0.090/0.500	3997.73 secs	(1.305 mins)	0.077	0.227


49.3/70.0	0.070/0.500	4061.97 secs	(1.071 mins)	0.034	0.227
49.3/70.0	0.071/0.500	4120.98 secs	(59.01 secs)	0.031	0.204
49.3/70.0	0.072/0.500	4182.29 secs	(1.022 mins)	0.030	0.223
49.3/70.0	0.073/0.500	4245.15 secs	(1.048 mins)	0.034	0.216
49.3/70.0	0.074/0.500	4307.63 secs	(1.041 mins)	0.036	0.222
49.3/70.0	0.075/0.500	4378.46 secs	(1.181 mins)	0.043	0.216
49.3/70.0	0.076/0.500	4442.60 secs	(1.069 mins)	0.041	0.220
49.3/70.0	0.077/0.500	4509.09 secs	(1.108 mins)	0.044	0.216
49.3/70.0	0.078/0.500	4573.40 secs	(1.072 mins)	0.040	0.213
49.3/70.0	0.079/0.500	4632.98 secs	(59.58 secs)	0.045	0.217
49.3/70.0	0.080/0.500	4692.87 secs	(59.89 secs)	0.038	0.210
49.3/70.0	0.081/0.500	4755.69 secs	(1.047 mins)	0.049	0.236
49.3/70.0	0.082/0.500	