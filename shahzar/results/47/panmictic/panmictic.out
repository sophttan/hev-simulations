
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list = ls())
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 284765 15.3     664565 35.5   464468 24.9
Vcells 490458  3.8    8388608 64.0  1837328 14.1
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> library(readr)
> library(foreach)
> library(doParallel)
Loading required package: iterators
Loading required package: parallel
> 
> # Set up the number of cores used for parallelization.
> message(detectCores())
24
> num_cores <- detectCores()
> registerDoParallel(num_cores)
> 
> #########################
> #### SEIR Simulation ####
> #########################
> time <- 365 # Number of days.
> inf <- 7 # Average infectious period length.
> N <- 1000 # Population size.
> 
> create_hh <- function() {
+   # Randomly sample household sizes such that total population is 1000 
+   # individuals.
+   hh_size <- sample(x = c(3, 4, 5, 6), size = 340, replace = T)
+   
+   # Keep households such that total population is < 1000.
+   hh_size <- hh_size[which(cumsum(hh_size) < N)]
+   
+   leftover <- N - sum(hh_size)
+   if (leftover < 3) {
+     hh <- 1:length(hh_size)
+     sampled <- sample(hh[hh_size < 6], leftover)
+     hh_size[sampled] <- hh_size[sampled] + 1
+   } else {
+     hh_size <- c(hh_size, leftover)
+   }
+   return(hh_size)
+ }
> 
> SEIR <- function(params, inf = 7, verbose = F) {
+   hh_size <- create_hh()
+   
+   # Create frame for running the simulation.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # S: susceptibility status.
+   # E: exposed status.
+   # E_count: number of days since exposed.
+   # I: infectious status.
+   # I_count: number of days since infectious.
+   # R: recovered status.
+   # INC: incubation period.
+   # INF: infectious period.
+   data <- data.frame(ID = 1:N,
+                      SIZE = rep(hh_size, times = hh_size),
+                      HH = rep(1:length(hh_size), times = hh_size), 
+                      S = c(0, rep(1, N - 1)), 
+                      E = c(1, rep(0, N - 1)),
+                      E_count = c(1, rep(0, N - 1)), 
+                      I = 0,
+                      I_count = 0, 
+                      R = 0, 
+                      INC = c(round(rlnorm(1, meanlog = log(29.8), sdlog = 0.45)), rep(0, N - 1)),
+                      INF = 0)
+   
+   # Create frame for storing results.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # TYPE: the kind of infection: household (H), community (C), or both (B).
+   # TIME: when the individual became infectious.
+   # S_num: number of susceptible people in individual's household when their 
+   #        infectious period begins.
+   # I_num: number of people in household that this individual infected over 
+   #        their infectious period.
+   results <- data[, 1:3] %>% mutate(TYPE = NA, TIME = NA, S_num = NA, I_num = 0)
+   results$TYPE[1] <- '0'
+     
+   for(t in 1:time) {
+     if (verbose) {
+       if (t %% 10 == 0) {
+         cat(paste0(t, ' '))
+       }
+     }
+     
+     # Anyone who has been infectious for as many days as their infectious period
+     # is now recovered.
+     recovered <- (data$INF > 0) & (data$I_count == data$INF)
+     if(sum(recovered, na.rm = T) > 0) {
+       data$R[recovered] <- 1
+       data$I[recovered] <- 0
+       data$I_count[recovered] <- 0 
+     }
+     
+     # Anyone who has been incubating for as many days as their incubation period
+     # is now infectious.
+     new_inf <- (data$INC > 0) & (data$E_count == data$INC)
+     num_new_inf <- sum(new_inf, na.rm = T)
+     if(num_new_inf > 0) {
+       # Change status to newly infectious and add infectious period.
+       data$I[new_inf] <- 1
+       random_inf <- rnorm(num_new_inf, mean = inf, sd = 1) %>% round()
+       data$INF[new_inf] <- random_inf
+       
+       # Remove exposure status and exposure count.
+       data$E[new_inf] <- 0
+       data$E_count[new_inf] <- 0 
+       
+       results$TIME[new_inf] <- t
+     }
+     
+     # risk is proportional to number infected, leading to exponential growth.
+     beta_E <- params[1] 
+     risk_E <- pmin(beta_E * data$S  * sum(data$I) / N, 1)
+     
+     new_exposed <- rbinom(N, 1, risk_E)
+     num_new_exposed <- sum(new_exposed, na.rm = T)
+     if(num_new_exposed > 0) {
+       # Change status to newly exposed and add incubation period.
+       data$E[new_exposed == 1] <- 1
+       random_inc <- rlnorm(num_new_exposed, meanlog = log(29.8), sdlog = 0.45) %>% round()
+       data$INC[new_exposed == 1] <- random_inc
+       
+       # Remove susceptible status.
+       data$S[new_exposed == 1] <- 0
+         
+       # Label infection types.
+       results$TYPE[new_exposed == 1] <- 'E'
+     }
+     
+     # Increment exposure and infectious counters.
+     data$E_count[data$E == 1] <- data$E_count[data$E == 1] + 1
+     data$I_count[data$I == 1] <- data$I_count[data$I == 1] + 1
+   }
+   return(results)
+ }
> 
> metrics <- function(results) {
+   # Incidence is the proportion of the population that became infected.
+   idc <- mean(!is.na(results$TIME))
+   return(c(idc))
+ }
> 
> beta_Es <- c(seq(0.195, 0.198, 0.0001), seq(0.219, 0.222, 0.0001), seq(0.270, 0.271, 0.0001))
> 
> d_E <- length(beta_Es)
> 
> reps <- 100000
> idcs <- array(rep(NA, d_E * reps), dim = c(d_E, reps))
> t_tot <- 0
> for (i in 1:d_E) {
+   beta_E <- beta_Es[i]
+   params <- c(beta_E)
+   cat(paste0(format(beta_E, nsmall = 4, scientific = F), '/0.300\t'))
+         
+   t_0 <- Sys.time()
+   vals <- foreach (l = 1:reps, .combine = 'c') %dopar% {
+     results <- SEIR(params) 
+     metrics(results)
+   }
+   t_1 <- Sys.time()
+   t_tot <- t_tot + (t_1 - t_0)
+         
+   cat(paste0(format(t_tot, nsmall = 2, digits = 4), '\t(', 
+              format(t_1 - t_0, nsmall = 2, digits = 4), ')\t'))
+       
+   vals <- matrix(vals, reps, byrow = T)
+   idcs[i] <- vals[, 1]
+         
+   cat(paste0(format(round(mean(vals[, 1]), 3), nsmall = 3), '\n'))
+     
+   saveRDS(idcs, file = 'idcs.rds')
+   write.table(idcs, file = 'idcs.txt', row.names = F, col.names = F)
+ }
0.1950/0.300	7.966 mins	(7.966 mins)	0.048
0.1951/0.300	16.44 mins	(8.477 mins)	0.048
0.1952/0.300	24.99 mins	(8.55 mins)	0.048
0.1953/0.300	33.53 mins	(8.541 mins)	0.049
0.1954/0.300	42.11 mins	(8.577 mins)	0.048
0.1955/0.300	50.73 mins	(8.615 mins)	0.049
0.1956/0.300	59.32 mins	(8.592 mins)	0.049
0.1957/0.300	67.90 mins	(8.587 mins)	0.049
0.1958/0.300	76.50 mins	(8.597 mins)	0.049
0.1959/0.300	85.09 mins	(8.589 mins)	0.049
0.1960/0.300	93.73 mins	(8.637 mins)	0.049
0.1961/0.300	102.31 mins	(8.579 mins)	0.049
0.1962/0.300	110.93 mins	(8.62 mins)	0.049
0.1963/0.300	119.53 mins	(8.608 mins)	0.049
0.1964/0.300	128.16 mins	(8.624 mins)	0.050
0.1965/0.300	136.82 mins	(8.658 mins)	0.050
0.1966/0.300	145.45 mins	(8.638 mins)	0.051
0.1967/0.300	154.33 mins	(8.879 mins)	0.051
0.1968/0.300	163.33 mins	(8.998 mins)	0.051
0.1969/0.300	171.96 mins	(8.631 mins)	0.051
0.1970/0.300	180.64 mins	(8.675 mins)	0.051
0.1971/0.300	189.30 mins	(8.665 mins)	0.051
0.1972/0.300	197.96 mins	(8.658 mins)	0.051
0.1973/0.300	206.60 mins	(8.642 mins)	0.051
0.1974/0.300	215.26 mins	(8.66 mins)	0.052
0.1975/0.300	223.92 mins	(8.66 mins)	0.052
0.1976/0.300	232.58 mins	(8.655 mins)	0.052
0.1977/0.300	241.27 mins	(8.692 mins)	0.052
0.1978/0.300	249.93 mins	(8.662 mins)	0.052
0.1979/0.300	258.60 mins	(8.665 mins)	0.052
0.1980/0.300	267.28 mins	(8.686 mins)	0.053
0.2190/0.300	276.73 mins	(9.446 mins)	0.097
0.2191/0.300	286.17 mins	(9.439 mins)	0.097
0.2192/0.300	295.64 mins	(9.468 mins)	0.097
0.2193/0.300	305.11 mins	(9.474 mins)	0.098
0.2194/0.300	314.55 mins	(9.44 mins)	0.098
0.2195/0.300	324.02 mins	(9.465 mins)	0.098
0.2196/0.300	333.49 mins	(9.473 mins)	0.098
0.2197/0.300	342.96 mins	(9.473 mins)	0.099
0.2198/0.300	352.41 mins	(9.454 mins)	0.098
0.2199/0.300	361.87 mins	(9.456 mins)	0.098
0.2200/0.300	371.34 mins	(9.469 mins)	0.099
0.2201/0.300	380.82 mins	(9.483 mins)	0.099
0.2202/0.300	390.31 mins	(9.485 mins)	0.100
0.2203/0.300	399.78 mins	(9.476 mins)	0.100
0.2204/0.300	409.28 mins	(9.497 mins)	0.100
0.2205/0.300	418.80 mins	(9.521 mins)	0.101
0.2206/0.300	428.41 mins	(9.613 mins)	0.101
0.2207/0.300	438.46 mins	(10.05 mins)	0.101
0.2208/0.300	448.01 mins	(9.546 mins)	0.101
0.2209/0.300	457.54 mins	(9.533 mins)	0.102
0.2210/0.300	467.09 mins	(9.545 mins)	0.103
0.2211/0.300	476.59 mins	(9.502 mins)	0.102
0.2212/0.300	486.11 mins	(9.517 mins)	0.102
0.2213/0.300	495.64 mins	(9.531 mins)	0.103
0.2214/0.300	505.18 mins	(9.541 mins)	0.103
0.2215/0.300	514.75 mins	(9.566 mins)	0.104
0.2216/0.300	524.31 mins	(9.561 mins)	0.103
0.2217/0.300	533.85 mins	(9.542 mins)	0.104
0.2218/0.300	543.45 mins	(9.597 mins)	0.105
0.2219/0.300	553.01 mins	(9.569 mins)	0.105
0.2220/0.300	562.56 mins	(9.55 mins)	0.104
0.2700/0.300	573.98 mins	(11.42 mins)	0.298
0.2701/0.300	585.39 mins	(11.41 mins)	0.298
0.2702/0.300	596.77 mins	(11.38 mins)	0.299
0.2703/0.300	608.17 mins	(11.40 mins)	0.299
0.2704/0.300	619.58 mins	(11.41 mins)	0.300
0.2705/0.300	631.02 mins	(11.44 mins)	0.303
0.2706/0.300	642.46 mins	(11.44 mins)	0.302
0.2707/0.300	653.93 mins	(11.47 mins)	0.302
0.2708/0.300	665.32 mins	(11.39 mins)	0.301
0.2709/0.300	676.77 mins	(11.45 mins)	0.303
0.2710/0.300	688.21 mins	(11.44 mins)	0.304
There were 50 or more warnings (use warnings() to see the first 50)
> 
> proc.time()
      user     system    elapsed 
954852.755    869.317  41451.764 
