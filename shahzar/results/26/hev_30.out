
R version 4.2.2 Patched (2022-11-10 r83330) -- "Innocent and Trusting"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list = ls())
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 275507 14.8     663402 35.5   469283 25.1
Vcells 463357  3.6    8388608 64.0  1822500 14.0
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> library(foreach)
> library(doParallel)
Loading required package: iterators
Loading required package: parallel
> 
> # Set up the number of cores used for parallelization.
> num_cores <- 24
> registerDoParallel(num_cores)
> 
> #########################
> #### SEIR Simulation ####
> #########################
> time <- 365 # Number of days.
> inc <- 28 # Average incubation period length.
> inf <- 7 # Average infectious period length.
> N <- 1000 # Population size.
> 
> create_hh <- function() {
+   # Randomly sample household sizes such that total population is 1000 
+   # individuals.
+   hh_size <- sample(x = c(3, 4, 5, 6), size = 340, replace = T)
+   
+   # Keep households such that total population is < 1000.
+   hh_size <- hh_size[which(cumsum(hh_size) < N)]
+   
+   leftover <- N - sum(hh_size)
+   if (leftover < 3) {
+     hh <- 1:length(hh_size)
+     sampled <- sample(hh[hh_size < 6], leftover)
+     hh_size[sampled] <- hh_size[sampled] + 1
+   } else {
+     hh_size <- c(hh_size, leftover)
+   }
+   return(hh_size)
+ }
> 
> SEIR <- function(params, inc, inf, verbose = F) {
+   hh_size <- create_hh()
+   
+   # Create frame for running the simulation.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # S: susceptibility status.
+   # E: exposed status.
+   # E_count: number of days since exposed.
+   # I: infectious status.
+   # I_count: number of days since infectious.
+   # R: recovered status.
+   # INC: incubation period.
+   # INF: infectious period.
+   data <- data.frame(ID = 1:N,
+                     SIZE = rep(hh_size, times = hh_size),
+                     HH = rep(1:length(hh_size), times = hh_size), 
+                     S = c(0, rep(1, N - 1)), 
+                     E = c(1, rep(0, N - 1)),
+                     E_count = c(1, rep(0, N - 1)), 
+                     I = 0,
+                     I_count = 0, 
+                     R = 0, 
+                     INC = c(round(rnorm(1, inc, 2)), rep(0, N - 1)),
+                     INF = 0)
+   
+   # Create frame for storing results.
+   # ID: ID of individual.
+   # SIZE: size of individual's household.
+   # HH: ID of individual's household.
+   # TYPE: the kind of infection: household (H), community (C), or both (B).
+   # TIME: when the individual became infectious.
+   # S_num: number of susceptible people in individual's household when their 
+   #        infectious period begins.
+   # I_num: number of people in household that this individual infected over 
+   #        their infectious period.
+   results <- data[, 1:3] %>% mutate(TYPE = NA, TIME = NA, S_num = NA, I_num = 0)
+   results$TYPE[1] <- '0'
+   
+   for(t in 1:time) {
+     if (verbose) {
+       if (t %% 10 == 0) {
+         cat(paste0(t, ' '))
+       }
+     }
+     
+     # Anyone who has been infectious for as many days as their infectious period
+     # is now recovered.
+     recovered <- (data$INF > 0) & (data$I_count == data$INF)
+     if(sum(recovered, na.rm = T) > 0) {
+       data$R[recovered] <- 1
+       data$I[recovered] <- 0
+       data$I_count[recovered] <- 0 
+     }
+     
+     # Anyone who has been incubating for as many days as their incubation period
+     # is now infectious.
+     new_inf <- (data$INC > 0) & (data$E_count == data$INC)
+     num_new_inf <- sum(new_inf, na.rm = T)
+     if(num_new_inf > 0) {
+       # Change status to newly infectious and add infectious period.
+       data$I[new_inf] <- 1
+       random_inf <- rnorm(num_new_inf, mean = inf, sd = 1) %>% round()
+       data$INF[new_inf] <- random_inf
+       
+       # Remove exposure status and exposure count.
+       data$E[new_inf] <- 0
+       data$E_count[new_inf] <- 0 
+       
+       # Record time at which infectious period starts.
+       results$TIME[new_inf] <- t
+       
+       # Save the number of susceptible people in each infectious individual's 
+       # household.
+       S_data <- data %>% group_by(HH) %>% 
+         mutate(S_tot = sum(S)) %>% 
+         select(HH, S_tot)
+       results$S_num[new_inf == 1] <- S_data$S_tot[new_inf == 1]
+     }
+     
+     # I_H is the number of infections inside each household.
+     # I_C is the number of infections outside each household.
+     I_data <- data %>% group_by(HH) %>% 
+       mutate(I_H = sum(I)) %>% 
+       ungroup() %>% 
+       mutate(I_C = sum(I) - I_H)
+     
+     # Calculate household risk and community risk.
+     beta_H <- params[1]
+     beta_C <- params[2]
+     risk_H <- beta_H * data$S * I_data$I_H / N
+     risk_C <- beta_C * data$S * I_data$I_C / N
+     
+     # Each individual is infected from their household or community 
+     # independently with probabilities risk_H and risk_C.
+     new_inf_H <- rbinom(nrow(data), 1, risk_H)
+     new_inf_C <- rbinom(nrow(data), 1, risk_C)
+     
+     new_exposed <- (new_inf_H == 1) | (new_inf_C == 1)
+     num_new_exposed <- sum(new_exposed, na.rm = T)
+     if (num_new_exposed > 0) {
+       # Change status to newly exposed and add incubation period.
+       data$E[new_exposed] <- 1
+       random_inc <- rnorm(num_new_exposed, mean = inc, sd = 2) %>% round()
+       data$INC[new_exposed] <- random_inc
+       
+       # Remove susceptible status.
+       data$S[new_exposed] <- 0
+       
+       # Label community infections with C and household infections with H.
+       results$TYPE[new_inf_C == 1] <- 'C'
+       results$TYPE[new_inf_H == 1] <- 'H'
+       
+       # Get number of new infections in each household.
+       I_data <- I_data %>%
+         select(ID, HH, I, I_H) %>%
+         mutate(new_I_H = new_inf_H) %>%
+         group_by(HH) %>%
+         # Find households with at least 1 currently infectious individual. If 
+         # exactly 1 infectious individual in household, assign all new H 
+         # exposures to that individual. If there are multiple infectious 
+         # individuals, assign all infections to the infectious individual with 
+         # the first ID.
+         mutate(new_I_H = ifelse(I == 1 & ID == first(ID[I == 1]), 
+                                 sum(new_I_H), 0))
+       
+       results$I_num <- results$I_num + I_data$new_I_H
+         
+       # Label individuals with both a household and community infection with B.
+       results$TYPE[(new_inf_H == 1) & (new_inf_C == 1)] <- 'B'
+     }
+     
+     # Increment exposure and infectious counters.
+     data$E_count[data$E == 1] <- data$E_count[data$E == 1] + 1
+     data$I_count[data$I == 1] <- data$I_count[data$I == 1] + 1
+   }
+   return(results)
+ }
> 
> metrics <- function(results) {
+   # Incidence is the proportion of the population that became infected.
+   idc <- mean(!is.na(results$TIME))
+   
+   # If incidence is 0, the SAR is undefined.
+   sar <- NA
+   if (idc != 0) {
+     # The SAR is the average SAR for each individual that was infectious.
+     sar <- mean(results$I_num / results$S_num, na.rm = T)
+   }
+   return(c(idc, sar))
+ }
> 
> ##############################
> #### Metropolis Algorithm ####
> ##############################
> score <- function(obs, target) {
+   # The score is the L² distance of the observed values from the target.
+   return(sum((obs - target)^2))
+ }
> 
> # The likelihood is calculated by first averaging the incidence and SAR over n
> # simulations with the state parameters. The likelihood is the negative log
> # score of the average incidence and SAR.
> likelihood <- function(state, target, n = 300) {
+   # If either parameter is nonpositive, do not transition to that state.
+   if (any(state <= 0)) {
+     return(-Inf)
+   }
+   # Otherwise, find the average incidence and SAR and compute likelihood.
+   vals <- foreach (i = 1:n, .combine = c) %dopar% {
+     results <- SEIR(state, inc, inf)
+     metrics(results)
+   }
+   vals <- matrix(vals, n, byrow = T)
+   avg_vals <- colMeans(vals)
+   return(-log(score(avg_vals, target)))
+ }
> 
> # Proposal function
> q <- function(state, sds = c(0.1, 0.001)) {
+   # Sample from a multivariate normal distributions centered at the current 
+   # state. The SDs roughly correspond to the step-size of the chain for each 
+   # parameter.
+   return(rnorm(n = 2, mean = state, sd = sds))
+ }
> 
> # MCMC
> metropolis <- function(start, target, num_sim, num_iter) {
+   path <- matrix(NA, num_iter + 1, 2)
+   liks <- rep(NA, num_iter + 1)
+   
+   # Initialize current state.
+   curr <- start
+   curr_lik <- likelihood(curr, target, num_sim)
+   
+   # Initialize best state.
+   best <- curr
+   best_lik <- curr_lik
+   for (i in 1:num_iter) {
+     # Save the current state and its likelihood.
+     path[i, ] <- curr
+     liks[i] <- curr_lik
+     
+     # Get a proposed state and calculate its likelihood.
+     prop <- q(curr)
+     prop_lik <- likelihood(prop, target, num_sim)
+     
+     # Compute the ratio of the scores of the two states and generate a uniform 
+     # bit.
+     r <- exp(prop_lik - curr_lik)
+     p <- runif(1)
+     
+     # Print the current progress.
+     message(paste0(i, '\t[', round(curr[1], 3), '\t', round(curr[2], 5), 
+                    ']\t', round(curr_lik, 3), '\t', 
+                    '\t[', round(prop[1], 3), '\t', round(prop[2], 5), ']\t',
+                    round(prop_lik, 3), '\t', round(r, 3), '\t', round(p, 3)))
+     
+     # Transition if the proposed state is better or if the coin flip succeeds.
+     if (p < r) { 
+       curr <- prop
+       curr_lik <- prop_lik
+       
+       # If the new likelihood is better than the best we've seen so far, replace 
+       # the best.
+       if (curr_lik > best_lik) {
+         best <- curr
+         best_lik <- curr_lik
+       }
+     }
+     
+     # Save the path, best state, and likelihoods so far.
+     write.table(path, file = '30/path.txt', row.names = F, col.names = F)
+     write.table(liks, file = '30/liks.txt', row.names = F, col.names = F)
+     write.table(best, file = '30/best.txt', row.names = F, col.names = F)
+   }
+   path[num_iter + 1, ] <- curr
+   liks[num_iter + 1] <- curr_lik
+   return(list(path, liks, best))
+ }
> 
> # Solve for optimal values via MCMC.
> target <- c(0.30, 0.25)
> start <- c(53.0802365426012, 0.122289394443056)
> results <- metropolis(start, target, num_sim = 1000, num_iter = 500)
1	[53.08	0.12229]	9.777		[53.329	0.12256]	9.197	0.56	0.763
2	[53.08	0.12229]	9.777		[53.208	0.12264]	9.715	0.94	0.816
3	[53.208	0.12264]	9.715		[53.325	0.12291]	8.055	0.19	0.814
4	[53.208	0.12264]	9.715		[53.121	0.12156]	9.609	0.9	0.76
5	[53.121	0.12156]	9.609		[53.06	0.12106]	9.855	1.278	0.526
6	[53.06	0.12106]	9.855		[53.212	0.11998]	7.569	0.102	0.576
7	[53.06	0.12106]	9.855		[53.2	0.12104]	11.12	3.543	0.648
8	[53.2	0.12104]	11.12		[52.999	0.12056]	8.289	0.059	0.461
9	[53.2	0.12104]	11.12		[53.231	0.12033]	12.036	2.501	0.573
10	[53.231	0.12033]	12.036		[53.359	0.1209]	9.691	0.096	0.372
11	[53.231	0.12033]	12.036		[53.03	0.12136]	11.733	0.739	0.728
12	[53.03	0.12136]	11.733		[53.084	0.11907]	7.358	0.013	0.798
13	[53.03	0.12136]	11.733		[53.002	0.12292]	8.599	0.044	0.506
14	[53.03	0.12136]	11.733		[53.046	0.1223]	10.36	0.253	0.246
15	[53.046	0.1223]	10.36		[52.904	0.1222]	9.444	0.4	0.162
16	[52.904	0.1222]	9.444		[53.013	0.12059]	9.002	0.643	0.055
17	[53.013	0.12059]	9.002		[53.027	0.1229]	7.449	0.212	0.884
18	[53.013	0.12059]	9.002		[52.983	0.12028]	8.466	0.585	0.529
19	[52.983	0.12028]	8.466		[52.997	0.12091]	11.902	31.063	0.364
20	[52.997	0.12091]	11.902		[52.931	0.12046]	9.056	0.058	0.014
21	[52.931	0.12046]	9.056		[52.871	0.12295]	10.214	3.184	0.625
22	[52.871	0.12295]	10.214		[52.871	0.12306]	9.178	0.355	0.574
23	[52.871	0.12295]	10.214		[52.906	0.12421]	8.042	0.114	0.598
24	[52.871	0.12295]	10.214		[52.776	0.123]	9.069	0.318	0.296
25	[52.776	0.123]	9.069		[52.684	0.12308]	9.193	1.132	0.636
26	[52.684	0.12308]	9.193		[52.629	0.12207]	8.489	0.494	0.093
27	[52.629	0.12207]	8.489		[52.61	0.12234]	11.624	22.986	0.464
28	[52.61	0.12234]	11.624		[52.692	0.12209]	8.831	0.061	0.444
29	[52.61	0.12234]	11.624		[52.585	0.1229]	8.125	0.03	0.945
30	[52.61	0.12234]	11.624		[52.562	0.12132]	7.933	0.025	0.135
31	[52.61	0.12234]	11.624		[52.749	0.12129]	9.944	0.186	0.156
32	[52.749	0.12129]	9.944		[52.688	0.12378]	8.201	0.175	0.894
33	[52.749	0.12129]	9.944		[52.635	0.1215]	8.586	0.257	0.495
34	[52.749	0.12129]	9.944		[52.888	0.12158]	9.639	0.737	0.956
35	[52.749	0.12129]	9.944		[52.846	0.1199]	9.561	0.682	0.663
36	[52.846	0.1199]	9.561		[52.974	0.12168]	9.823	1.299	0.891
37	[52.974	0.12168]	9.823		[52.828	0.12225]	8.849	0.378	0.303
38	[52.828	0.12225]	8.849		[52.684	0.12208]	13.619	117.937	0.95
39	[52.684	0.12208]	13.619		[52.837	0.12368]	8.974	0.01	0.393
40	[52.684	0.12208]	13.619		[52.616	0.12138]	7.526	0.002	0.864
41	[52.684	0.12208]	13.619		[52.664	0.12057]	7.843	0.003	0.669
42	[52.684	0.12208]	13.619		[52.739	0.12221]	10.042	0.028	0.771
43	[52.684	0.12208]	13.619		[52.727	0.12009]	8.786	0.008	0.212
44	[52.684	0.12208]	13.619		[52.8	0.12285]	10.294	0.036	0.433
45	[52.684	0.12208]	13.619		[52.618	0.12147]	9.546	0.017	0.149
46	[52.684	0.12208]	13.619		[52.822	0.12212]	10.418	0.041	0.36
47	[52.684	0.12208]	13.619		[52.82	0.1214]	9.248	0.013	0.489
48	[52.684	0.12208]	13.619		[52.744	0.12193]	11.61	0.134	0.191
49	[52.684	0.12208]	13.619		[52.737	0.12131]	13.727	1.114	0.48
50	[52.737	0.12131]	13.727		[52.594	0.12153]	8.375	0.005	0.322
51	[52.737	0.12131]	13.727		[52.817	0.1214]	9.212	0.011	0.605
52	[52.737	0.12131]	13.727		[52.606	0.12174]	8.87	0.008	0.403
53	[52.737	0.12131]	13.727		[52.663	0.12212]	11.63	0.123	0.675
54	[52.737	0.12131]	13.727		[52.651	0.11979]	9.714	0.018	0.121
55	[52.737	0.12131]	13.727		[52.871	0.12114]	10.472	0.039	0.557
56	[52.737	0.12131]	13.727		[52.981	0.12062]	7.955	0.003	0.597
57	[52.737	0.12131]	13.727		[52.699	0.12247]	11.311	0.089	0.184
58	[52.737	0.12131]	13.727		[52.8	0.1216]	9.177	0.011	0.577
59	[52.737	0.12131]	13.727		[52.824	0.1206]	7.344	0.002	0.769
60	[52.737	0.12131]	13.727		[52.776	0.12051]	9.714	0.018	0.285
61	[52.737	0.12131]	13.727		[52.867	0.12313]	8.89	0.008	0.607
62	[52.737	0.12131]	13.727		[52.679	0.1208]	10.626	0.045	0.123
63	[52.737	0.12131]	13.727		[52.827	0.12127]	8.86	0.008	0.087
64	[52.737	0.12131]	13.727		[52.688	0.12239]	8.694	0.007	0.884
65	[52.737	0.12131]	13.727		[52.663	0.11961]	8.385	0.005	0.603
66	[52.737	0.12131]	13.727		[52.698	0.12142]	9.704	0.018	0.102
67	[52.737	0.12131]	13.727		[52.734	0.1189]	9.374	0.013	0.048
68	[52.737	0.12131]	13.727		[52.773	0.1232]	8.913	0.008	0.144
69	[52.737	0.12131]	13.727		[52.882	0.12092]	10.725	0.05	0.901
70	[52.737	0.12131]	13.727		[52.638	0.11988]	7.569	0.002	0.93
71	[52.737	0.12131]	13.727		[52.641	0.12037]	11.725	0.135	0.673
72	[52.737	0.12131]	13.727		[52.673	0.12346]	8.395	0.005	0.002
73	[52.673	0.12346]	8.395		[52.846	0.12452]	6.881	0.22	0.229
74	[52.673	0.12346]	8.395		[52.621	0.12422]	7.781	0.541	0.961
75	[52.673	0.12346]	8.395		[52.606	0.12418]	9.914	4.565	0.651
76	[52.606	0.12418]	9.914		[52.594	0.1241]	9.667	0.781	0.795
77	[52.606	0.12418]	9.914		[52.469	0.12395]	7.604	0.099	0.37
78	[52.606	0.12418]	9.914		[52.571	0.1257]	6.911	0.05	0.779
79	[52.606	0.12418]	9.914		[52.461	0.12366]	8.791	0.325	0.705
80	[52.606	0.12418]	9.914		[52.557	0.12449]	8.427	0.226	0.062
81	[52.557	0.12449]	8.427		[52.453	0.1224]	8.373	0.948	0.534
82	[52.453	0.1224]	8.373		[52.539	0.12126]	8.387	1.014	0.919
83	[52.539	0.12126]	8.387		[52.563	0.12244]	10.775	10.887	0.3
84	[52.563	0.12244]	10.775		[52.556	0.12119]	9.662	0.329	0.062
85	[52.556	0.12119]	9.662		[52.595	0.12146]	8.145	0.219	0.913
86	[52.556	0.12119]	9.662		[52.678	0.1213]	7.573	0.124	0.019
87	[52.678	0.1213]	7.573		[52.679	0.12239]	8.867	3.649	0.573
88	[52.679	0.12239]	8.867		[52.629	0.12119]	8.102	0.465	0.126
89	[52.629	0.12119]	8.102		[52.784	0.12153]	8.143	1.042	0.665
90	[52.784	0.12153]	8.143		[52.708	0.1219]	9.378	3.438	0.868
91	[52.708	0.1219]	9.378		[52.831	0.12236]	11.546	8.741	0.317
92	[52.831	0.12236]	11.546		[52.913	0.12143]	9.34	0.11	0.889
93	[52.831	0.12236]	11.546		[52.878	0.12337]	7.884	0.026	0.766
94	[52.831	0.12236]	11.546		[52.849	0.12066]	9.595	0.142	0.648
95	[52.831	0.12236]	11.546		[52.774	0.12338]	10.214	0.264	0.402
96	[52.831	0.12236]	11.546		[52.821	0.12263]	8.838	0.067	0.201
97	[52.831	0.12236]	11.546		[52.779	0.12122]	9.705	0.159	0.94
98	[52.831	0.12236]	11.546		[52.882	0.12176]	9.252	0.101	0.833
99	[52.831	0.12236]	11.546		[52.929	0.1218]	11.586	1.041	0.988
100	[52.929	0.1218]	11.586		[52.994	0.12047]	10.981	0.546	0.594
101	[52.929	0.1218]	11.586		[52.881	0.12231]	9.176	0.09	0.521
102	[52.929	0.1218]	11.586		[52.77	0.12298]	8.527	0.047	0.408
103	[52.929	0.1218]	11.586		[52.958	0.12272]	8.444	0.043	0.35
104	[52.929	0.1218]	11.586		[52.859	0.12218]	10.807	0.459	0.104
105	[52.859	0.12218]	10.807		[52.991	0.12057]	9.558	0.287	0.815
106	[52.859	0.12218]	10.807		[52.674	0.12115]	9.368	0.237	0.201
107	[52.674	0.12115]	9.368		[52.714	0.12152]	9.539	1.186	0.51
108	[52.714	0.12152]	9.539		[52.778	0.11985]	8.309	0.292	0.576
109	[52.714	0.12152]	9.539		[52.641	0.1227]	9.449	0.914	0.336
110	[52.641	0.1227]	9.449		[52.65	0.12262]	10.075	1.871	0.906
111	[52.65	0.12262]	10.075		[52.929	0.12086]	12.501	11.307	0.196
112	[52.929	0.12086]	12.501		[52.966	0.12122]	13.08	1.785	0.469
113	[52.966	0.12122]	13.08		[52.945	0.12033]	7.517	0.004	0.517
114	[52.966	0.12122]	13.08		[52.991	0.12166]	10.922	0.116	0.444
115	[52.966	0.12122]	13.08		[53.147	0.12145]	12.069	0.364	0.886
116	[52.966	0.12122]	13.08		[52.826	0.12216]	10.95	0.119	0.131
117	[52.966	0.12122]	13.08		[52.823	0.11944]	8.448	0.01	0.815
118	[52.966	0.12122]	13.08		[52.933	0.12268]	8.137	0.007	0.799
119	[52.966	0.12122]	13.08		[52.928	0.12091]	10.332	0.064	0.451
120	[52.966	0.12122]	13.08		[53.061	0.1224]	10.88	0.111	0.81
121	[52.966	0.12122]	13.08		[53.012	0.12119]	9.18	0.02	0.976
122	[52.966	0.12122]	13.08		[53.068	0.12004]	9.762	0.036	0.967
123	[52.966	0.12122]	13.08		[53.219	0.12149]	12.975	0.9	0.246
124	[53.219	0.12149]	12.975		[53.417	0.12141]	10.327	0.071	0.649
125	[53.219	0.12149]	12.975		[53.147	0.1227]	10.011	0.052	0.834
126	[53.219	0.12149]	12.975		[53.284	0.12223]	8.751	0.015	0.281
127	[53.219	0.12149]	12.975		[53.098	0.12091]	9.154	0.022	0.47
128	[53.219	0.12149]	12.975		[53.232	0.12106]	12.005	0.379	0.902
129	[53.219	0.12149]	12.975		[53.323	0.12244]	8.519	0.012	0.375
130	[53.219	0.12149]	12.975		[53.144	0.1229]	7.741	0.005	0.141
131	[53.219	0.12149]	12.975		[53.331	0.12122]	8.161	0.008	0.415
132	[53.219	0.12149]	12.975		[53.394	0.12135]	13.262	1.333	0.792
133	[53.394	0.12135]	13.262		[53.449	0.12393]	9.034	0.015	0.777
134	[53.394	0.12135]	13.262		[53.342	0.12032]	8.475	0.008	0.576
135	[53.394	0.12135]	13.262		[53.42	0.12159]	10.083	0.042	0.828
136	[53.394	0.12135]	13.262		[53.285	0.12141]	13.411	1.16	0.449
137	[53.285	0.12141]	13.411		[53.191	0.12082]	9.544	0.021	0.026
138	[53.285	0.12141]	13.411		[53.25	0.12221]	8.383	0.007	0.202
139	[53.285	0.12141]	13.411		[53.322	0.12012]	8.428	0.007	0.857
140	[53.285	0.12141]	13.411		[53.157	0.12251]	10.251	0.042	0.948
141	[53.285	0.12141]	13.411		[53.33	0.12181]	8.935	0.011	0.485
142	[53.285	0.12141]	13.411		[53.18	0.12368]	8.432	0.007	0.271
143	[53.285	0.12141]	13.411		[53.302	0.11985]	8.525	0.008	0.736
144	[53.285	0.12141]	13.411		[53.357	0.12014]	7.51	0.003	0.079
145	[53.285	0.12141]	13.411		[53.228	0.12242]	9.395	0.018	0.187
146	[53.285	0.12141]	13.411		[53.256	0.12069]	10.127	0.037	0.822
147	[53.285	0.12141]	13.411		[53.094	0.1203]	8.339	0.006	0.311
148	[53.285	0.12141]	13.411		[53.285	0.12274]	9.273	0.016	0.549
149	[53.285	0.12141]	13.411		[53.563	0.12198]	9.33	0.017	0.755
150	[53.285	0.12141]	13.411		[53.224	0.12348]	8.329	0.006	0.341
151	[53.285	0.12141]	13.411		[53.328	0.11945]	9.38	0.018	0.242
152	[53.285	0.12141]	13.411		[53.269	0.12085]	8.378	0.007	0.375
153	[53.285	0.12141]	13.411		[53.149	0.12142]	10.591	0.06	0.913
154	[53.285	0.12141]	13.411		[53.384	0.12033]	8.893	0.011	0.158
155	[53.285	0.12141]	13.411		[53.415	0.12131]	10.188	0.04	0.608
156	[53.285	0.12141]	13.411		[53.231	0.11945]	8.519	0.008	0.578
157	[53.285	0.12141]	13.411		[53.215	0.1218]	10.213	0.041	0.824
158	[53.285	0.12141]	13.411		[53.246	0.12014]	8.468	0.007	0.703
159	[53.285	0.12141]	13.411		[53.411	0.12049]	8.671	0.009	0.544
160	[53.285	0.12141]	13.411		[53.406	0.11996]	8.39	0.007	0.869
161	[53.285	0.12141]	13.411		[53.323	0.12088]	11.592	0.162	0.562
162	[53.285	0.12141]	13.411		[53.283	0.12269]	11.083	0.098	0.037
163	[53.283	0.12269]	11.083		[53.22	0.12214]	10.144	0.391	0.559
164	[53.283	0.12269]	11.083		[53.2	0.12256]	9.605	0.228	0.252
165	[53.283	0.12269]	11.083		[53.188	0.12164]	8.3	0.062	0.921
166	[53.283	0.12269]	11.083		[53.227	0.12335]	7.541	0.029	0.364
167	[53.283	0.12269]	11.083		[53.268	0.12276]	9.723	0.257	0.469
168	[53.283	0.12269]	11.083		[53.303	0.122]	12.154	2.919	0.582
169	[53.303	0.122]	12.154		[53.361	0.12099]	9.898	0.105	0.157
170	[53.303	0.122]	12.154		[53.22	0.12051]	10.957	0.302	0.27
171	[53.22	0.12051]	10.957		[53.143	0.12233]	10.226	0.482	0.83
172	[53.22	0.12051]	10.957		[53.347	0.12155]	8.342	0.073	0.492
173	[53.22	0.12051]	10.957		[53.085	0.11872]	9.476	0.227	0.645
174	[53.22	0.12051]	10.957		[53.292	0.11938]	7.603	0.035	0.796
